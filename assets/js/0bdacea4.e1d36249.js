"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[9483],{4059:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2-digital-twin/simulating-sensors-actuators","title":"Simulating Sensors and Actuators in Gazebo","description":"A simulated robot is not very useful unless it can sense its environment and act upon it. In Gazebo, this is achieved through plugins. Plugins are shared libraries that are loaded at runtime and can interact with the simulation.","source":"@site/docs/module-2-digital-twin/simulating-sensors-actuators.mdx","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/simulating-sensors-actuators","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-2-digital-twin/simulating-sensors-actuators","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"sidebar_label":"Simulating Sensors and Actuators"},"sidebar":"mainSidebar","previous":{"title":"Robot Models in Simulation","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-2-digital-twin/robot-models-simulation"},"next":{"title":"ROS 2 Integration with Simulation","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-2-digital-twin/ros2-integration-simulation"}}');var a=o(4848),i=o(8453);const t={sidebar_label:"Simulating Sensors and Actuators"},r="Simulating Sensors and Actuators in Gazebo",l={},c=[{value:"Simulating Sensors",id:"simulating-sensors",level:2},{value:"1. Lidar (Laser Scanner)",id:"1-lidar-laser-scanner",level:3},{value:"2. IMU (Inertial Measurement Unit)",id:"2-imu-inertial-measurement-unit",level:3},{value:"3. Camera",id:"3-camera",level:3},{value:"Simulating Actuators and <code>ros2_control</code>",id:"simulating-actuators-and-ros2_control",level:2},{value:"How <code>ros2_control</code> Works with Gazebo",id:"how-ros2_control-works-with-gazebo",level:3},{value:"Example <code>ros2_control</code> URDF Tags",id:"example-ros2_control-urdf-tags",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"simulating-sensors-and-actuators-in-gazebo",children:"Simulating Sensors and Actuators in Gazebo"})}),"\n",(0,a.jsxs)(n.p,{children:["A simulated robot is not very useful unless it can sense its environment and act upon it. In Gazebo, this is achieved through ",(0,a.jsx)(n.strong,{children:"plugins"}),". Plugins are shared libraries that are loaded at runtime and can interact with the simulation."]}),"\n",(0,a.jsx)(n.p,{children:"Gazebo provides a set of ROS 2 plugins that make it easy to simulate a wide variety of sensors and actuators."}),"\n",(0,a.jsx)(n.h2,{id:"simulating-sensors",children:"Simulating Sensors"}),"\n",(0,a.jsx)(n.p,{children:"Let's look at how to simulate some of the most common sensors in robotics."}),"\n",(0,a.jsx)(n.h3,{id:"1-lidar-laser-scanner",children:"1. Lidar (Laser Scanner)"}),"\n",(0,a.jsxs)(n.p,{children:["A Lidar is essential for many navigation and mapping tasks. The ",(0,a.jsx)(n.code,{children:"libgazebo_ros_ray_sensor.so"})," plugin can simulate a Lidar."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="lidar_link">\n  <sensor type="ray" name="my_lidar">\n    <pose>0 0 0 0 0 0</pose>\n    <visualize>true</visualize>\n    <update_rate>10</update_rate>\n    <ray>\n      <scan>\n        <horizontal>\n          <samples>720</samples>\n          <resolution>1</resolution>\n          <min_angle>-1.570796</min_angle>\n          <max_angle>1.570796</max_angle>\n        </horizontal>\n      </scan>\n      <range>\n        <min>0.10</min>\n        <max>30.0</max>\n        <resolution>0.01</resolution>\n      </range>\n    </ray>\n    <plugin name="gazebo_ros_ray_sensor" filename="libgazebo_ros_ray_sensor.so">\n      <ros>\n        <namespace>/my_robot</namespace>\n        <output_type>sensor_msgs/LaserScan</output_type>\n        <topic>scan</topic>\n      </ros>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This plugin will publish ",(0,a.jsx)(n.code,{children:"sensor_msgs/LaserScan"})," messages to the ",(0,a.jsx)(n.code,{children:"/my_robot/scan"})," topic."]}),"\n",(0,a.jsx)(n.h3,{id:"2-imu-inertial-measurement-unit",children:"2. IMU (Inertial Measurement Unit)"}),"\n",(0,a.jsxs)(n.p,{children:["An IMU is used for estimating the robot's orientation and velocity. The ",(0,a.jsx)(n.code,{children:"libgazebo_ros_imu_sensor.so"})," plugin can simulate an IMU."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="imu_link">\n  <sensor name="my_imu" type="imu">\n    <always_on>true</always_on>\n    <update_rate>100</update_rate>\n    <plugin name="imu_plugin" filename="libgazebo_ros_imu_sensor.so">\n      <ros>\n        <namespace>/my_robot</namespace>\n        <topic>imu</topic>\n      </ros>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This plugin will publish ",(0,a.jsx)(n.code,{children:"sensor_msgs/Imu"})," messages to the ",(0,a.jsx)(n.code,{children:"/my_robot/imu"})," topic."]}),"\n",(0,a.jsx)(n.h3,{id:"3-camera",children:"3. Camera"}),"\n",(0,a.jsxs)(n.p,{children:["We saw an example of a camera plugin in the previous section. The ",(0,a.jsx)(n.code,{children:"libgazebo_ros_camera.so"})," plugin is very versatile and can be configured to simulate different types of cameras, including RGB, depth, and thermal cameras."]}),"\n",(0,a.jsxs)(n.h2,{id:"simulating-actuators-and-ros2_control",children:["Simulating Actuators and ",(0,a.jsx)(n.code,{children:"ros2_control"})]}),"\n",(0,a.jsxs)(n.p,{children:["Simulating actuators involves controlling the robot's joints. While you can use plugins like the differential drive plugin for simple cases, a more general and powerful approach is to use the ",(0,a.jsx)(n.code,{children:"ros2_control"})," framework."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"ros2_control"})," is a standard framework in ROS 2 for real-time control of robots. It provides a consistent interface for controlling your robot's hardware, whether it's real or simulated."]}),"\n",(0,a.jsxs)(n.h3,{id:"how-ros2_control-works-with-gazebo",children:["How ",(0,a.jsx)(n.code,{children:"ros2_control"})," Works with Gazebo"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"gazebo_ros2_control"})," package provides a Gazebo plugin that acts as a bridge between Gazebo and ",(0,a.jsx)(n.code,{children:"ros2_control"}),". Here's how it works:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["URDF with ",(0,a.jsx)(n.code,{children:"ros2_control"})," tags:"]})," You add special ",(0,a.jsx)(n.code,{children:"<ros2_control>"})," tags to your URDF to define the joints and interfaces that ",(0,a.jsx)(n.code,{children:"ros2_control"})," will manage."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Gazebo Plugin:"})," You add the ",(0,a.jsx)(n.code,{children:"gazebo_ros2_control"})," plugin to your URDF. This plugin reads the ",(0,a.jsx)(n.code,{children:"ros2_control"})," tags and loads the appropriate hardware interfaces for Gazebo."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Controllers:"})," You can then load and start various controllers from the ",(0,a.jsx)(n.code,{children:"ros2_controllers"})," package, such as a ",(0,a.jsx)(n.code,{children:"joint_state_broadcaster"})," to publish the state of the joints, or a ",(0,a.jsx)(n.code,{children:"diff_drive_controller"})," to control a wheeled robot."]}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"example-ros2_control-urdf-tags",children:["Example ",(0,a.jsx)(n.code,{children:"ros2_control"})," URDF Tags"]}),"\n",(0,a.jsxs)(n.p,{children:["Here is an example of how you might add ",(0,a.jsx)(n.code,{children:"ros2_control"})," tags to your URDF for a differential drive robot:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<ros2_control name="GazeboSystem" type="system">\n  <hardware>\n    <plugin>gazebo_ros2_control/GazeboSystem</plugin>\n  </hardware>\n  <joint name="left_wheel_joint">\n    <command_interface name="velocity"/>\n    <state_interface name="position"/>\n    <state_interface name="velocity"/>\n  </joint>\n  <joint name="right_wheel_joint">\n    <command_interface name="velocity"/>\n    <state_interface name="position"/>\n    <state_interface name="velocity"/>\n  </joint>\n</ros2_control>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This tells ",(0,a.jsx)(n.code,{children:"ros2_control"})," to manage the ",(0,a.jsx)(n.code,{children:"left_wheel_joint"})," and ",(0,a.jsx)(n.code,{children:"right_wheel_joint"}),", and that they can be controlled by sending velocity commands."]}),"\n",(0,a.jsxs)(n.p,{children:["Using ",(0,a.jsx)(n.code,{children:"ros2_control"})," is the recommended approach for controlling your robot in simulation, as it allows you to use the same control code for both your simulated and physical robot, which is a core principle of the digital twin philosophy."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>t,x:()=>r});var s=o(6540);const a={},i=s.createContext(a);function t(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);