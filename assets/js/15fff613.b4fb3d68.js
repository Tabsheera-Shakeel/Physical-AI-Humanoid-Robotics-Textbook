"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3157],{5243:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"module-2-digital-twin/robot-models-simulation","title":"Creating and Using Robot Models for Simulation","description":"To bring your robot into a simulated world, you need a detailed model that the simulator can understand. As we learned in Module 1, the standard format for this in the ROS ecosystem is URDF (Unified Robot Description Format), often written with Xacro for simplicity.","source":"@site/docs/module-2-digital-twin/robot-models-simulation.mdx","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/robot-models-simulation","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-2-digital-twin/robot-models-simulation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"sidebar_label":"Robot Models in Simulation"},"sidebar":"mainSidebar","previous":{"title":"Intro to Gazebo and Unity","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-2-digital-twin/intro-gazebo-unity"},"next":{"title":"Simulating Sensors and Actuators","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-2-digital-twin/simulating-sensors-actuators"}}');var t=i(4848),a=i(8453);const s={sidebar_label:"Robot Models in Simulation"},r="Creating and Using Robot Models for Simulation",l={},d=[{value:"From URDF to Simulation Model",id:"from-urdf-to-simulation-model",level:2},{value:"Extending URDF for Gazebo",id:"extending-urdf-for-gazebo",level:2},{value:"1. Adding Materials and Colors",id:"1-adding-materials-and-colors",level:3},{value:"2. Setting Physics Properties",id:"2-setting-physics-properties",level:3},{value:"3. Adding Sensor Plugins",id:"3-adding-sensor-plugins",level:3},{value:"4. Adding Actuator Plugins",id:"4-adding-actuator-plugins",level:3},{value:"Spawning a Robot in Gazebo",id:"spawning-a-robot-in-gazebo",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"creating-and-using-robot-models-for-simulation",children:"Creating and Using Robot Models for Simulation"})}),"\n",(0,t.jsxs)(n.p,{children:["To bring your robot into a simulated world, you need a detailed model that the simulator can understand. As we learned in Module 1, the standard format for this in the ROS ecosystem is ",(0,t.jsx)(n.strong,{children:"URDF (Unified Robot Description Format)"}),", often written with ",(0,t.jsx)(n.strong,{children:"Xacro"})," for simplicity."]}),"\n",(0,t.jsx)(n.p,{children:"However, a basic URDF file only describes the robot's kinematics (its structure). For a realistic simulation, we need to add more information, such as dynamics, collision properties, and sensor definitions."}),"\n",(0,t.jsx)(n.h2,{id:"from-urdf-to-simulation-model",children:"From URDF to Simulation Model"}),"\n",(0,t.jsx)(n.p,{children:"A simulation-ready robot model typically includes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Visual Meshes:"})," Detailed 3D models (e.g., in ",(0,t.jsx)(n.code,{children:".dae"})," or ",(0,t.jsx)(n.code,{children:".stl"})," format) that define the visual appearance of each link."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Collision Meshes:"})," Simpler 3D models that define the collision geometry of each link. Using simpler meshes for collision detection improves performance."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inertial Properties:"})," The mass and inertia tensor for each link, which are crucial for accurate physics simulation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Simulation-Specific Properties:"})," Additional information required by the simulator, such as friction coefficients, damping, and sensor definitions."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"extending-urdf-for-gazebo",children:"Extending URDF for Gazebo"}),"\n",(0,t.jsxs)(n.p,{children:["Gazebo uses the ",(0,t.jsx)(n.strong,{children:"Simulation Description Format (SDF)"})," internally. While Gazebo can import URDF files, it's often necessary to add Gazebo-specific information using the ",(0,t.jsx)(n.code,{children:"<gazebo>"})," tag within your URDF."]}),"\n",(0,t.jsxs)(n.p,{children:["Here are some common uses of the ",(0,t.jsx)(n.code,{children:"<gazebo>"})," tag:"]}),"\n",(0,t.jsx)(n.h3,{id:"1-adding-materials-and-colors",children:"1. Adding Materials and Colors"}),"\n",(0,t.jsx)(n.p,{children:"You can specify the color of a link in Gazebo."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="my_link">\n  <material>Gazebo/Red</material>\n</gazebo>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-setting-physics-properties",children:"2. Setting Physics Properties"}),"\n",(0,t.jsx)(n.p,{children:"You can define friction and damping for a link's collision geometry."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="my_link">\n  <mu1>0.8</mu1>\n  <mu2>0.8</mu2>\n</gazebo>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-adding-sensor-plugins",children:"3. Adding Sensor Plugins"}),"\n",(0,t.jsx)(n.p,{children:"This is one of the most powerful features. You can attach a sensor to a link and configure it using a Gazebo plugin. For example, here is how you might add a camera sensor:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="camera_link">\n  <sensor type="camera" name="my_camera">\n    <update_rate>30.0</update_rate>\n    <camera name="head">\n      <horizontal_fov>1.3962634</horizontal_fov>\n      <image>\n        <width>800</width>\n        <height>800</height>\n        <format>R8G8B8</format>\n      </image>\n    </camera>\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n      <ros>\n        <namespace>/my_robot</namespace>\n        <image_topic>image_raw</image_topic>\n        <camera_info_topic>camera_info</camera_info_topic>\n      </ros>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This XML snippet defines a camera sensor, sets its properties (update rate, resolution, etc.), and uses the ",(0,t.jsx)(n.code,{children:"libgazebo_ros_camera.so"})," plugin to publish the camera images to a ROS 2 topic."]}),"\n",(0,t.jsx)(n.h3,{id:"4-adding-actuator-plugins",children:"4. Adding Actuator Plugins"}),"\n",(0,t.jsx)(n.p,{children:"You can also add plugins to control the robot's joints. A common example is the differential drive plugin for wheeled robots."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<gazebo>\n  <plugin name="differential_drive_controller" filename="libgazebo_ros_diff_drive.so">\n    <ros>\n        <namespace>/my_robot</namespace>\n    </ros>\n    <left_joint>left_wheel_joint</left_joint>\n    <right_joint>right_wheel_joint</right_joint>\n    <wheel_separation>0.35</wheel_separation>\n    <wheel_diameter>0.2</wheel_diameter>\n    <command_topic>cmd_vel</command_topic>\n    <odometry_topic>odom</odometry_topic>\n    <odometry_frame>odom</odometry_frame>\n    <robot_base_frame>base_link</robot_base_frame>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This plugin takes ",(0,t.jsx)(n.code,{children:"Twist"})," messages from the ",(0,t.jsx)(n.code,{children:"/my_robot/cmd_vel"})," topic and uses them to control the left and right wheel joints. It also publishes odometry information."]}),"\n",(0,t.jsx)(n.h2,{id:"spawning-a-robot-in-gazebo",children:"Spawning a Robot in Gazebo"}),"\n",(0,t.jsx)(n.p,{children:"Once you have your simulation-ready URDF file, you can spawn it into a running Gazebo simulation."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Launch Gazebo:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"ros2 launch gazebo_ros gazebo.launch.py\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Spawn the Robot:"})," Use the ",(0,t.jsx)(n.code,{children:"spawn_entity.py"})," script from the ",(0,t.jsx)(n.code,{children:"gazebo_ros"})," package to spawn your robot. You need to provide the path to your URDF file.","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"ros2 run gazebo_ros spawn_entity.py -entity my_robot -file /path/to/your/robot.urdf\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Creating a high-fidelity simulation model is an iterative process. You will likely start with a simple URDF and gradually add more detail as you develop your robot's capabilities. The next section will delve deeper into simulating sensors and actuators."})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>r});var o=i(6540);const t={},a=o.createContext(t);function s(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);